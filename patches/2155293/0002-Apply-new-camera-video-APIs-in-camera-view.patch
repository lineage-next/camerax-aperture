From 8278f548863b07d512d8f5955e5453f5eca34793 Mon Sep 17 00:00:00 2001
From: mingdatsai <mingdatsai@google.com>
Date: Thu, 3 Mar 2022 12:11:13 +0800
Subject: [PATCH 2/5] Apply new camera-video APIs in camera-view

(1) Use VideoCapture use case from camera-video instead of camera-core
, and update the related code.
(2) Use method overloading to support starting recording in three
different output formats, File, FileDescriptor and MediaStore.
(3) Use Quality instead of OutputSize for video resolution setting,
because the new API no longer supports setTargetResolution().
(4) Add test cases to cover the recording related code in both
camera-view & camera-view test app.

Relnote: "Apply the new video capture API. The getVideoCaptureTargetSize
and setVideoCaptureTargetSize methods are replaced with the
getVideoCaptureTargetQuality and the setVideoCaptureTargetQuality
methods accordingly, as setTargetResolution is no longer supported."

Bug: 209528390
Test: run CameraControllerTest, VideoCaptureDeviceTest
& CameraControllerFragmentTest

Change-Id: I2a1d597eb4d42346803da392d27a99235d258723
---
 .../public_plus_experimental_1.2.0-beta01.txt |   9 +-
 .../api/public_plus_experimental_current.txt  |   9 +-
 camera/camera-view/build.gradle               |   2 +
 .../camera/view/VideoCaptureDeviceTest.kt     | 621 ++++++++++++++++++
 .../camera/view/CameraController.java         | 335 ++++++++--
 .../camera/view/CameraControllerTest.kt       |  21 +-
 .../viewtestapp/build.gradle                  |   1 +
 .../view/CameraControllerFragmentTest.kt      | 156 +++++
 .../view/CameraControllerFragment.java        |  88 ++-
 9 files changed, 1127 insertions(+), 115 deletions(-)
 create mode 100644 camera/camera-view/src/androidTest/java/androidx/camera/view/VideoCaptureDeviceTest.kt

diff --git a/camera/camera-view/api/public_plus_experimental_1.2.0-beta01.txt b/camera/camera-view/api/public_plus_experimental_1.2.0-beta01.txt
index e27e9b7ec51..bd0b7ab2e5c 100644
--- a/camera/camera-view/api/public_plus_experimental_1.2.0-beta01.txt
+++ b/camera/camera-view/api/public_plus_experimental_1.2.0-beta01.txt
@@ -19,7 +19,7 @@ package androidx.camera.view {
     method @MainThread public androidx.camera.view.CameraController.OutputSize? getPreviewTargetSize();
     method @MainThread public androidx.lifecycle.LiveData<java.lang.Integer!> getTapToFocusState();
     method @MainThread public androidx.lifecycle.LiveData<java.lang.Integer!> getTorchState();
-    method @MainThread @androidx.camera.view.video.ExperimentalVideo public androidx.camera.view.CameraController.OutputSize? getVideoCaptureTargetSize();
+    method @MainThread @androidx.camera.view.video.ExperimentalVideo public androidx.camera.video.Quality? getVideoCaptureTargetQuality();
     method @MainThread public androidx.lifecycle.LiveData<androidx.camera.core.ZoomState!> getZoomState();
     method @MainThread public boolean hasCamera(androidx.camera.core.CameraSelector);
     method @MainThread public boolean isImageAnalysisEnabled();
@@ -43,10 +43,11 @@ package androidx.camera.view {
     method @MainThread public void setPinchToZoomEnabled(boolean);
     method @MainThread public void setPreviewTargetSize(androidx.camera.view.CameraController.OutputSize?);
     method @MainThread public void setTapToFocusEnabled(boolean);
-    method @MainThread @androidx.camera.view.video.ExperimentalVideo public void setVideoCaptureTargetSize(androidx.camera.view.CameraController.OutputSize?);
+    method @MainThread @androidx.camera.view.video.ExperimentalVideo public void setVideoCaptureTargetQuality(androidx.camera.video.Quality?);
     method @MainThread public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setZoomRatio(float);
-    method @MainThread @androidx.camera.view.video.ExperimentalVideo public void startRecording(androidx.camera.view.video.OutputFileOptions, java.util.concurrent.Executor, androidx.camera.view.video.OnVideoSavedCallback);
-    method @MainThread @androidx.camera.view.video.ExperimentalVideo public void stopRecording();
+    method @MainThread @RequiresPermission(android.Manifest.permission.RECORD_AUDIO) @androidx.camera.view.video.ExperimentalVideo public androidx.camera.video.Recording startRecording(androidx.camera.video.FileOutputOptions, java.util.concurrent.Executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent!>);
+    method @MainThread @RequiresApi(26) @RequiresPermission(android.Manifest.permission.RECORD_AUDIO) @androidx.camera.view.video.ExperimentalVideo public androidx.camera.video.Recording startRecording(androidx.camera.video.FileDescriptorOutputOptions, java.util.concurrent.Executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent!>);
+    method @MainThread @RequiresPermission(android.Manifest.permission.RECORD_AUDIO) @androidx.camera.view.video.ExperimentalVideo public androidx.camera.video.Recording startRecording(androidx.camera.video.MediaStoreOutputOptions, java.util.concurrent.Executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent!>);
     method @MainThread public void takePicture(androidx.camera.core.ImageCapture.OutputFileOptions, java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageSavedCallback);
     method @MainThread public void takePicture(java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageCapturedCallback);
     field public static final int COORDINATE_SYSTEM_VIEW_REFERENCED = 1; // 0x1
diff --git a/camera/camera-view/api/public_plus_experimental_current.txt b/camera/camera-view/api/public_plus_experimental_current.txt
index e27e9b7ec51..bd0b7ab2e5c 100644
--- a/camera/camera-view/api/public_plus_experimental_current.txt
+++ b/camera/camera-view/api/public_plus_experimental_current.txt
@@ -19,7 +19,7 @@ package androidx.camera.view {
     method @MainThread public androidx.camera.view.CameraController.OutputSize? getPreviewTargetSize();
     method @MainThread public androidx.lifecycle.LiveData<java.lang.Integer!> getTapToFocusState();
     method @MainThread public androidx.lifecycle.LiveData<java.lang.Integer!> getTorchState();
-    method @MainThread @androidx.camera.view.video.ExperimentalVideo public androidx.camera.view.CameraController.OutputSize? getVideoCaptureTargetSize();
+    method @MainThread @androidx.camera.view.video.ExperimentalVideo public androidx.camera.video.Quality? getVideoCaptureTargetQuality();
     method @MainThread public androidx.lifecycle.LiveData<androidx.camera.core.ZoomState!> getZoomState();
     method @MainThread public boolean hasCamera(androidx.camera.core.CameraSelector);
     method @MainThread public boolean isImageAnalysisEnabled();
@@ -43,10 +43,11 @@ package androidx.camera.view {
     method @MainThread public void setPinchToZoomEnabled(boolean);
     method @MainThread public void setPreviewTargetSize(androidx.camera.view.CameraController.OutputSize?);
     method @MainThread public void setTapToFocusEnabled(boolean);
-    method @MainThread @androidx.camera.view.video.ExperimentalVideo public void setVideoCaptureTargetSize(androidx.camera.view.CameraController.OutputSize?);
+    method @MainThread @androidx.camera.view.video.ExperimentalVideo public void setVideoCaptureTargetQuality(androidx.camera.video.Quality?);
     method @MainThread public com.google.common.util.concurrent.ListenableFuture<java.lang.Void!> setZoomRatio(float);
-    method @MainThread @androidx.camera.view.video.ExperimentalVideo public void startRecording(androidx.camera.view.video.OutputFileOptions, java.util.concurrent.Executor, androidx.camera.view.video.OnVideoSavedCallback);
-    method @MainThread @androidx.camera.view.video.ExperimentalVideo public void stopRecording();
+    method @MainThread @RequiresPermission(android.Manifest.permission.RECORD_AUDIO) @androidx.camera.view.video.ExperimentalVideo public androidx.camera.video.Recording startRecording(androidx.camera.video.FileOutputOptions, java.util.concurrent.Executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent!>);
+    method @MainThread @RequiresApi(26) @RequiresPermission(android.Manifest.permission.RECORD_AUDIO) @androidx.camera.view.video.ExperimentalVideo public androidx.camera.video.Recording startRecording(androidx.camera.video.FileDescriptorOutputOptions, java.util.concurrent.Executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent!>);
+    method @MainThread @RequiresPermission(android.Manifest.permission.RECORD_AUDIO) @androidx.camera.view.video.ExperimentalVideo public androidx.camera.video.Recording startRecording(androidx.camera.video.MediaStoreOutputOptions, java.util.concurrent.Executor, androidx.core.util.Consumer<androidx.camera.video.VideoRecordEvent!>);
     method @MainThread public void takePicture(androidx.camera.core.ImageCapture.OutputFileOptions, java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageSavedCallback);
     method @MainThread public void takePicture(java.util.concurrent.Executor, androidx.camera.core.ImageCapture.OnImageCapturedCallback);
     field public static final int COORDINATE_SYSTEM_VIEW_REFERENCED = 1; // 0x1
diff --git a/camera/camera-view/build.gradle b/camera/camera-view/build.gradle
index 56a6b628164..b8c3f12d1b7 100644
--- a/camera/camera-view/build.gradle
+++ b/camera/camera-view/build.gradle
@@ -27,6 +27,7 @@ dependencies {
     api("androidx.lifecycle:lifecycle-common:2.0.0")
     api("androidx.annotation:annotation:1.2.0")
     api(project(":camera:camera-core"))
+    api(project(":camera:camera-video"))
     implementation(project(":camera:camera-lifecycle"))
     implementation("androidx.annotation:annotation-experimental:1.1.0-rc01")
     implementation(libs.guavaListenableFuture)
@@ -61,6 +62,7 @@ dependencies {
     androidTestImplementation(project(":camera:camera-camera2"))
     androidTestImplementation(project(":camera:camera-testing"))
     androidTestImplementation(project(":camera:camera-camera2-pipe-integration"))
+    androidTestImplementation(project(":internal-testutils-truth"))
     androidTestImplementation(libs.mockitoCore, excludes.bytebuddy) // DexMaker has it's own MockMaker
     androidTestImplementation(libs.dexmakerMockito, excludes.bytebuddy) // DexMaker has it's own MockMaker
     androidTestImplementation("androidx.test.espresso:espresso-core:3.3.0")
diff --git a/camera/camera-view/src/androidTest/java/androidx/camera/view/VideoCaptureDeviceTest.kt b/camera/camera-view/src/androidTest/java/androidx/camera/view/VideoCaptureDeviceTest.kt
new file mode 100644
index 00000000000..1d81f1d6cc8
--- /dev/null
+++ b/camera/camera-view/src/androidTest/java/androidx/camera/view/VideoCaptureDeviceTest.kt
@@ -0,0 +1,621 @@
+/*
+ * Copyright 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package androidx.camera.view
+
+import android.Manifest
+import android.content.ContentResolver
+import android.content.ContentValues
+import android.content.Context
+import android.media.MediaMetadataRetriever
+import android.net.Uri
+import android.os.Build
+import android.os.ParcelFileDescriptor
+import android.provider.MediaStore
+import android.util.Log
+import androidx.annotation.MainThread
+import androidx.camera.core.impl.utils.executor.CameraXExecutors
+import androidx.camera.testing.CameraUtil
+import androidx.camera.testing.CoreAppTestUtil
+import androidx.camera.testing.CoreAppTestUtil.ForegroundOccupiedError
+import androidx.camera.testing.fakes.FakeActivity
+import androidx.camera.testing.fakes.FakeLifecycleOwner
+import androidx.camera.video.FileDescriptorOutputOptions
+import androidx.camera.video.FileOutputOptions
+import androidx.camera.video.MediaStoreOutputOptions
+import androidx.camera.video.OutputOptions
+import androidx.camera.video.Quality
+import androidx.camera.video.Recording
+import androidx.camera.video.VideoRecordEvent
+import androidx.camera.video.VideoRecordEvent.Finalize.ERROR_SOURCE_INACTIVE
+import androidx.camera.view.CameraController.IMAGE_ANALYSIS
+import androidx.camera.view.CameraController.VIDEO_CAPTURE
+import androidx.core.util.Consumer
+import androidx.test.core.app.ApplicationProvider
+import androidx.test.ext.junit.rules.ActivityScenarioRule
+import androidx.test.filters.LargeTest
+import androidx.test.filters.SdkSuppress
+import androidx.test.platform.app.InstrumentationRegistry
+import androidx.test.rule.GrantPermissionRule
+import androidx.testutils.assertThrows
+import com.google.common.truth.Truth.assertThat
+import java.io.File
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit
+import org.junit.After
+import org.junit.Assume
+import org.junit.Before
+import org.junit.BeforeClass
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TestRule
+import org.junit.runner.RunWith
+import org.junit.runners.Parameterized
+
+@LargeTest
+@RunWith(Parameterized::class)
+@SdkSuppress(minSdkVersion = 21)
+class VideoCaptureDeviceTest(
+    private val initialQuality: TargetQuality,
+    private val nextQuality: TargetQuality
+) {
+
+    /**
+     * The helper class to workaround the issue that "null" cannot be accepted as a parameter value
+     * in Parameterized tests, ref: b/37086576
+     */
+    enum class TargetQuality {
+        None, FHD, HD, HIGHEST, LOWEST, SD, UHD;
+
+        fun get(): Quality? {
+            return when (this) {
+                None -> null
+                FHD -> Quality.FHD
+                HD -> Quality.HD
+                HIGHEST -> Quality.HIGHEST
+                LOWEST -> Quality.LOWEST
+                SD -> Quality.SD
+                UHD -> Quality.UHD
+            }
+        }
+    }
+
+    companion object {
+        private const val VIDEO_TIMEOUT_SEC = 10L
+        private const val VIDEO_RECORDING_COUNT_DOWN = 5
+        private const val VIDEO_STARTED_COUNT_DOWN = 1
+        private const val VIDEO_SAVED_COUNT_DOWN = 1
+        private const val TAG = "VideoRecordingTest"
+
+        @JvmStatic
+        @BeforeClass
+        @Throws(ForegroundOccupiedError::class)
+        fun classSetUp() {
+            CoreAppTestUtil.prepareDeviceUI(InstrumentationRegistry.getInstrumentation())
+        }
+
+        @JvmStatic
+        @Parameterized.Parameters(name = "initialQuality={0}, nextQuality={1}")
+        fun data() = mutableListOf<Array<TargetQuality>>().apply {
+            add(arrayOf(TargetQuality.None, TargetQuality.FHD))
+            add(arrayOf(TargetQuality.FHD, TargetQuality.HD))
+            add(arrayOf(TargetQuality.HD, TargetQuality.HIGHEST))
+            add(arrayOf(TargetQuality.HIGHEST, TargetQuality.LOWEST))
+            add(arrayOf(TargetQuality.LOWEST, TargetQuality.SD))
+            add(arrayOf(TargetQuality.SD, TargetQuality.UHD))
+            add(arrayOf(TargetQuality.UHD, TargetQuality.None))
+        }
+    }
+
+    @get:Rule
+    val cameraRule: TestRule = CameraUtil.grantCameraPermissionAndPreTest()
+
+    @get:Rule
+    val activityRule: ActivityScenarioRule<FakeActivity> =
+        ActivityScenarioRule(FakeActivity::class.java)
+
+    @get:Rule
+    val permissionRule: GrantPermissionRule = GrantPermissionRule.grant(
+        Manifest.permission.WRITE_EXTERNAL_STORAGE,
+        Manifest.permission.RECORD_AUDIO
+    )
+
+    private val instrumentation = InstrumentationRegistry.getInstrumentation()
+    private val context: Context = ApplicationProvider.getApplicationContext()
+    private lateinit var previewView: PreviewView
+    private lateinit var lifecycleOwner: FakeLifecycleOwner
+    private lateinit var cameraController: LifecycleCameraController
+    private lateinit var activeRecording: Recording
+    private lateinit var latchForVideoStarted: CountDownLatch
+    private lateinit var latchForVideoPaused: CountDownLatch
+    private lateinit var latchForVideoResumed: CountDownLatch
+    private lateinit var latchForVideoSaved: CountDownLatch
+    private lateinit var latchForVideoRecording: CountDownLatch
+    private lateinit var finalize: VideoRecordEvent.Finalize
+
+    private val videoRecordEventListener = Consumer<VideoRecordEvent> {
+        when (it) {
+            is VideoRecordEvent.Start -> {
+                Log.d(TAG, "Recording start")
+                latchForVideoStarted.countDown()
+            }
+            is VideoRecordEvent.Finalize -> {
+                Log.d(TAG, "Recording finalize")
+                finalize = it
+                latchForVideoSaved.countDown()
+            }
+            is VideoRecordEvent.Status -> {
+                // Make sure the recording proceed for a while.
+                Log.d(TAG, "Recording Status")
+                latchForVideoRecording.countDown()
+            }
+            is VideoRecordEvent.Pause -> {
+                Log.d(TAG, "Recording Pause")
+                latchForVideoPaused.countDown()
+            }
+            is VideoRecordEvent.Resume -> {
+                Log.d(TAG, "Recording Resume")
+                latchForVideoResumed.countDown()
+            }
+            else -> {
+                throw IllegalStateException()
+            }
+        }
+    }
+
+    @Before
+    fun setUp() {
+        // Skip test for b/168175357
+        Assume.assumeFalse(
+            "Cuttlefish has MediaCodec dequeInput/Output buffer fails issue. Unable to test.",
+            Build.MODEL.contains("Cuttlefish") && Build.VERSION.SDK_INT == 29
+        )
+
+        initialLifecycleOwner()
+        initialPreviewView()
+        initialController()
+    }
+
+    @After
+    fun tearDown() {
+        if (this::cameraController.isInitialized) {
+            instrumentation.runOnMainSync {
+                cameraController.shutDownForTests()
+            }
+        }
+    }
+
+    @Test
+    fun canRecordToMediaStore() {
+        // Arrange.
+        val resolver: ContentResolver = context.contentResolver
+        val outputOptions = createMediaStoreOutputOptions(resolver)
+
+        // Act.
+        recordVideoCompletely(outputOptions)
+
+        // Verify.
+        val uri = finalize.outputResults.outputUri
+        assertThat(uri).isNotEqualTo(Uri.EMPTY)
+        checkFileHasAudioAndVideo(uri)
+
+        // Cleanup.
+        resolver.delete(uri, null, null)
+    }
+
+    @Test
+    @SdkSuppress(minSdkVersion = 26)
+    fun canRecordToFileDescriptor() {
+        // Arrange.
+        val file = createTempFile()
+        val fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_WRITE)
+        val outputOptions = FileDescriptorOutputOptions.Builder(fileDescriptor).build()
+
+        // Act.
+        recordVideoCompletely(outputOptions)
+
+        // Verify.
+        val uri = Uri.fromFile(file)
+        checkFileHasAudioAndVideo(uri)
+
+        // Cleanup.
+        fileDescriptor.close()
+        file.delete()
+    }
+
+    @Test
+    fun canRecordToFile() {
+        // Arrange.
+        val file = createTempFile()
+        val outputOptions = FileOutputOptions.Builder(file).build()
+
+        // Act.
+        recordVideoCompletely(outputOptions)
+
+        // Verify.
+        val uri = Uri.fromFile(file)
+        checkFileHasAudioAndVideo(uri)
+        assertThat(finalize.outputResults.outputUri).isEqualTo(uri)
+
+        // Cleanup.
+        file.delete()
+    }
+
+    @Test
+    fun canRecordToFile_whenLifecycleStops() {
+        // Arrange.
+        val file = createTempFile()
+        val outputOptions = FileOutputOptions.Builder(file).build()
+
+        // Act.
+        recordVideoWithInterruptAction(outputOptions) {
+            instrumentation.runOnMainSync {
+                lifecycleOwner.pauseAndStop()
+            }
+        }
+
+        // Verify.
+        assertThat(finalize.error).isEqualTo(ERROR_SOURCE_INACTIVE)
+        val uri = Uri.fromFile(file)
+        checkFileHasAudioAndVideo(uri)
+        assertThat(finalize.outputResults.outputUri).isEqualTo(uri)
+
+        // Cleanup.
+        file.delete()
+    }
+
+    @Test
+    fun canRecordToFile_whenTargetQualityChanged() {
+        // Arrange.
+        val file = createTempFile()
+        val outputOptions = FileOutputOptions.Builder(file).build()
+
+        // Act.
+        recordVideoWithInterruptAction(outputOptions) {
+            instrumentation.runOnMainSync {
+                cameraController.videoCaptureTargetQuality = nextQuality.get()
+            }
+        }
+
+        // Verify.
+        assertThat(finalize.error).isEqualTo(ERROR_SOURCE_INACTIVE)
+        val uri = Uri.fromFile(file)
+        checkFileHasAudioAndVideo(uri)
+        assertThat(finalize.outputResults.outputUri).isEqualTo(uri)
+
+        // Cleanup.
+        file.delete()
+    }
+
+    @Test
+    fun canRecordToFile_whenEnabledUseCasesChanged() {
+        // Arrange.
+        val file = createTempFile()
+        val outputOptions = FileOutputOptions.Builder(file).build()
+
+        // Act.
+        recordVideoWithInterruptAction(outputOptions) {
+            instrumentation.runOnMainSync {
+                cameraController.setEnabledUseCases(IMAGE_ANALYSIS)
+            }
+        }
+
+        // Verify.
+        assertThat(finalize.hasError()).isFalse()
+        val uri = Uri.fromFile(file)
+        checkFileHasAudioAndVideo(uri)
+        assertThat(finalize.outputResults.outputUri).isEqualTo(uri)
+
+        // Cleanup.
+        file.delete()
+    }
+
+    @Test
+    fun canRecordToFile_rightAfterPreviousRecordingStopped() {
+        // Arrange.
+        val file1 = createTempFile()
+        val file2 = createTempFile()
+        val outputOptions1 = FileOutputOptions.Builder(file1).build()
+        val outputOptions2 = FileOutputOptions.Builder(file2).build()
+
+        // Pre Act.
+        latchForVideoSaved = CountDownLatch(VIDEO_SAVED_COUNT_DOWN)
+        recordVideo(outputOptions1)
+        instrumentation.runOnMainSync {
+            activeRecording.stop()
+            assertThat(cameraController.isRecording).isFalse()
+        }
+
+        // Act.
+        instrumentation.runOnMainSync {
+            startRecording(outputOptions2)
+            assertThat(cameraController.isRecording).isTrue()
+        }
+
+        // Wait for the Finalize event of the previous recording.
+        assertThat(latchForVideoSaved.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+
+        // reset latches and wait for Start and Status events
+        latchForVideoStarted = CountDownLatch(VIDEO_STARTED_COUNT_DOWN)
+        latchForVideoRecording = CountDownLatch(VIDEO_RECORDING_COUNT_DOWN)
+        latchForVideoSaved = CountDownLatch(VIDEO_SAVED_COUNT_DOWN)
+        assertThat(latchForVideoStarted.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+        assertThat(latchForVideoRecording.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+
+        // Stop the second recording and wait for the Finalize event
+        instrumentation.runOnMainSync {
+            activeRecording.stop()
+            assertThat(cameraController.isRecording).isFalse()
+        }
+        assertThat(latchForVideoSaved.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+
+        // Verify.
+        assertThat(finalize.hasError()).isFalse()
+        val uri1 = Uri.fromFile(file1)
+        checkFileHasAudioAndVideo(uri1)
+        val uri2 = Uri.fromFile(file2)
+        checkFileHasAudioAndVideo(uri2)
+
+        // Cleanup.
+        file1.delete()
+        file2.delete()
+    }
+
+    @Test
+    fun canRecordToFile_whenPauseAndStop() {
+        val pauseTimes = 1
+
+        // Arrange.
+        latchForVideoPaused = CountDownLatch(pauseTimes)
+        val file = createTempFile()
+        val outputOptions = FileOutputOptions.Builder(file).build()
+
+        // Act.
+        recordVideoWithInterruptAction(outputOptions) {
+            instrumentation.runOnMainSync {
+                activeRecording.pause()
+            }
+            assertThat(latchForVideoPaused.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+
+            instrumentation.runOnMainSync {
+                activeRecording.stop()
+            }
+        }
+
+        // Verify.
+        val uri = Uri.fromFile(file)
+        checkFileHasAudioAndVideo(uri)
+        assertThat(finalize.outputResults.outputUri).isEqualTo(uri)
+
+        // Cleanup.
+        file.delete()
+    }
+
+    @Test
+    fun canRecordToFile_whenPauseAndResumeInTheMiddle() {
+        val pauseTimes = 1
+        val resumeTimes = 1
+
+        // Arrange.
+        latchForVideoPaused = CountDownLatch(pauseTimes)
+        latchForVideoResumed = CountDownLatch(resumeTimes)
+        val file = createTempFile()
+        val outputOptions = FileOutputOptions.Builder(file).build()
+
+        // Act.
+        recordVideoWithInterruptAction(outputOptions) {
+            instrumentation.runOnMainSync {
+                activeRecording.pause()
+            }
+            assertThat(latchForVideoPaused.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+
+            instrumentation.runOnMainSync {
+                activeRecording.resume()
+            }
+            assertThat(latchForVideoResumed.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+
+            instrumentation.runOnMainSync {
+                activeRecording.stop()
+            }
+        }
+
+        // Verify.
+        val uri = Uri.fromFile(file)
+        checkFileHasAudioAndVideo(uri)
+        assertThat(finalize.outputResults.outputUri).isEqualTo(uri)
+
+        // Cleanup.
+        file.delete()
+    }
+
+    @Test
+    fun startRecording_throwsExceptionWhenAlreadyInRecording() {
+        // Arrange.
+        val file1 = createTempFile()
+        val file2 = createTempFile()
+        val outputOptions1 = FileOutputOptions.Builder(file1).build()
+        val outputOptions2 = FileOutputOptions.Builder(file2).build()
+
+        // Act.
+        recordVideoWithInterruptAction(outputOptions1) {
+            instrumentation.runOnMainSync {
+                assertThrows(java.lang.IllegalStateException::class.java) {
+                    activeRecording = cameraController.startRecording(
+                        outputOptions2,
+                        CameraXExecutors.directExecutor()
+                    ) {}
+                }
+                activeRecording.stop()
+            }
+        }
+
+        // Cleanup.
+        file1.delete()
+        file2.delete()
+    }
+
+    private fun initialLifecycleOwner() {
+        lifecycleOwner = FakeLifecycleOwner()
+        lifecycleOwner.startAndResume()
+    }
+
+    private fun initialPreviewView() {
+        activityRule.scenario.onActivity { activity ->
+            previewView = PreviewView(context)
+            previewView.implementationMode = PreviewView.ImplementationMode.PERFORMANCE
+            activity.setContentView(previewView)
+        }
+    }
+
+    private fun initialController() {
+        cameraController = LifecycleCameraController(context)
+        cameraController.initializationFuture.get()
+        instrumentation.runOnMainSync {
+            if (initialQuality != TargetQuality.None) {
+                cameraController.videoCaptureTargetQuality = initialQuality.get()
+            }
+
+            //  If the PreviewView is not attached, the enabled use cases will not be applied.
+            previewView.controller = cameraController
+
+            cameraController.bindToLifecycle(lifecycleOwner)
+            cameraController.setEnabledUseCases(VIDEO_CAPTURE)
+        }
+    }
+
+    private fun createTempFile(): File {
+        return File.createTempFile("CameraX", ".tmp").apply {
+            deleteOnExit()
+        }
+    }
+
+    private fun createMediaStoreOutputOptions(resolver: ContentResolver): MediaStoreOutputOptions {
+        val videoFileName = "video_" + System.currentTimeMillis()
+        val contentValues = ContentValues()
+        contentValues.put(MediaStore.MediaColumns.MIME_TYPE, "video/mp4")
+        contentValues.put(MediaStore.Video.Media.TITLE, videoFileName)
+        contentValues.put(MediaStore.Video.Media.DISPLAY_NAME, videoFileName)
+        return MediaStoreOutputOptions
+            .Builder(resolver, MediaStore.Video.Media.EXTERNAL_CONTENT_URI)
+            .setContentValues(contentValues)
+            .build()
+    }
+
+    private fun recordVideoCompletely(outputOptions: OutputOptions) {
+        // Act.
+        recordVideoWithInterruptAction(outputOptions) {
+            instrumentation.runOnMainSync {
+                activeRecording.stop()
+            }
+        }
+
+        // Verify.
+        assertThat(finalize.hasError()).isFalse()
+    }
+
+    private fun recordVideoWithInterruptAction(
+        outputOptions: OutputOptions,
+        runInterruptAction: () -> Unit
+    ) {
+        // Arrange.
+        latchForVideoSaved = CountDownLatch(VIDEO_SAVED_COUNT_DOWN)
+
+        // Act.
+        recordVideo(outputOptions)
+        runInterruptAction()
+
+        // Verify.
+        // Wait for finalize event to saved file.
+        assertThat(latchForVideoSaved.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+
+        instrumentation.runOnMainSync {
+            assertThat(cameraController.isRecording).isFalse()
+        }
+    }
+
+    private fun recordVideo(outputOptions: OutputOptions) {
+        // Arrange.
+        latchForVideoStarted = CountDownLatch(VIDEO_STARTED_COUNT_DOWN)
+        latchForVideoRecording = CountDownLatch(VIDEO_RECORDING_COUNT_DOWN)
+
+        // Act.
+        instrumentation.runOnMainSync {
+            startRecording(outputOptions)
+            assertThat(cameraController.isRecording).isTrue()
+        }
+
+        // Verify.
+        assertThat(latchForVideoStarted.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+
+        // Wait for status event to proceed recording for a while.
+        assertThat(latchForVideoRecording.await(VIDEO_TIMEOUT_SEC, TimeUnit.SECONDS)).isTrue()
+    }
+
+    @MainThread
+    private fun startRecording(outputOptions: OutputOptions) {
+        if (outputOptions is FileOutputOptions) {
+            activeRecording = cameraController.startRecording(
+                outputOptions,
+                CameraXExecutors.directExecutor(),
+                videoRecordEventListener
+            )
+        } else if (outputOptions is FileDescriptorOutputOptions) {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                activeRecording = cameraController.startRecording(
+                    outputOptions,
+                    CameraXExecutors.directExecutor(),
+                    videoRecordEventListener
+                )
+            } else {
+                throw UnsupportedOperationException(
+                    "File descriptors are not supported on pre-Android O (API 26) devices."
+                )
+            }
+        } else if (outputOptions is MediaStoreOutputOptions) {
+            activeRecording = cameraController.startRecording(
+                outputOptions,
+                CameraXExecutors.directExecutor(),
+                videoRecordEventListener
+            )
+        } else {
+            throw IllegalArgumentException("Unsupported OutputOptions type.")
+        }
+    }
+
+    private fun checkFileHasAudioAndVideo(uri: Uri) {
+        checkFileHasVideo(uri)
+        checkFileHasAudio(uri)
+    }
+
+    private fun checkFileHasVideo(uri: Uri) {
+        val mediaRetriever = MediaMetadataRetriever()
+        mediaRetriever.apply {
+            setDataSource(context, uri)
+            val hasVideo = extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_VIDEO)
+            assertThat(hasVideo).isEqualTo("yes")
+        }
+    }
+
+    private fun checkFileHasAudio(uri: Uri) {
+        val mediaRetriever = MediaMetadataRetriever()
+        mediaRetriever.apply {
+            setDataSource(context, uri)
+            val value = extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_AUDIO)
+
+            assertThat(value).isEqualTo("yes")
+        }
+    }
+}
\ No newline at end of file
diff --git a/camera/camera-view/src/main/java/androidx/camera/view/CameraController.java b/camera/camera-view/src/main/java/androidx/camera/view/CameraController.java
index a0f314e1920..8fad5143176 100644
--- a/camera/camera-view/src/main/java/androidx/camera/view/CameraController.java
+++ b/camera/camera-view/src/main/java/androidx/camera/view/CameraController.java
@@ -19,7 +19,9 @@ package androidx.camera.view;
 import static androidx.camera.core.impl.utils.Threads.checkMainThread;
 import static androidx.camera.core.impl.utils.executor.CameraXExecutors.mainThreadExecutor;
 import static androidx.camera.view.CameraController.OutputSize.UNASSIGNED_ASPECT_RATIO;
+import static androidx.core.content.ContextCompat.getMainExecutor;
 
+import android.Manifest;
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.graphics.Matrix;
@@ -36,6 +38,7 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.OptIn;
 import androidx.annotation.RequiresApi;
+import androidx.annotation.RequiresPermission;
 import androidx.annotation.RestrictTo;
 import androidx.annotation.VisibleForTesting;
 import androidx.camera.core.AspectRatio;
@@ -59,19 +62,29 @@ import androidx.camera.core.Preview;
 import androidx.camera.core.TorchState;
 import androidx.camera.core.UseCase;
 import androidx.camera.core.UseCaseGroup;
-import androidx.camera.core.VideoCapture;
 import androidx.camera.core.ViewPort;
 import androidx.camera.core.ZoomState;
 import androidx.camera.core.impl.ImageOutputConfig;
+import androidx.camera.core.impl.utils.Threads;
 import androidx.camera.core.impl.utils.executor.CameraXExecutors;
 import androidx.camera.core.impl.utils.futures.FutureCallback;
 import androidx.camera.core.impl.utils.futures.Futures;
 import androidx.camera.lifecycle.ProcessCameraProvider;
+import androidx.camera.video.FallbackStrategy;
+import androidx.camera.video.FileDescriptorOutputOptions;
+import androidx.camera.video.FileOutputOptions;
+import androidx.camera.video.MediaStoreOutputOptions;
+import androidx.camera.video.OutputOptions;
+import androidx.camera.video.PendingRecording;
+import androidx.camera.video.Quality;
+import androidx.camera.video.QualitySelector;
+import androidx.camera.video.Recorder;
+import androidx.camera.video.Recording;
+import androidx.camera.video.VideoCapture;
+import androidx.camera.video.VideoRecordEvent;
 import androidx.camera.view.transform.OutputTransform;
 import androidx.camera.view.video.ExperimentalVideo;
-import androidx.camera.view.video.OnVideoSavedCallback;
-import androidx.camera.view.video.OutputFileOptions;
-import androidx.camera.view.video.OutputFileResults;
+import androidx.core.util.Consumer;
 import androidx.core.util.Preconditions;
 import androidx.lifecycle.LiveData;
 import androidx.lifecycle.MutableLiveData;
@@ -80,9 +93,10 @@ import com.google.common.util.concurrent.ListenableFuture;
 
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * The abstract base camera controller class.
@@ -118,6 +132,8 @@ public abstract class CameraController {
     private static final String CAMERA_NOT_ATTACHED = "Use cases not attached to camera.";
     private static final String IMAGE_CAPTURE_DISABLED = "ImageCapture disabled.";
     private static final String VIDEO_CAPTURE_DISABLED = "VideoCapture disabled.";
+    private static final String VIDEO_RECORDING_UNFINISHED = "Recording video. Only one recording"
+            + " can be active at a time.";
 
     // Auto focus is 1/6 of the area.
     private static final float AF_SIZE = 1.0f / 6.0f;
@@ -251,18 +267,17 @@ public abstract class CameraController {
     @Nullable
     OutputSize mImageAnalysisTargetSize;
 
-    // Synthetic access
-    @SuppressWarnings("WeakerAccess")
     @NonNull
-    VideoCapture mVideoCapture;
+    VideoCapture<Recorder> mVideoCapture;
+
+    @Nullable
+    Recording mActiveRecording = null;
 
-    // Synthetic access
-    @SuppressWarnings("WeakerAccess")
     @NonNull
-    final AtomicBoolean mVideoIsRecording = new AtomicBoolean(false);
+    Map<Consumer<VideoRecordEvent>, Recording> mRecordingMap = new HashMap<>();
 
     @Nullable
-    OutputSize mVideoCaptureOutputSize;
+    Quality mVideoCaptureQuality;
 
     // The latest bound camera.
     // Synthetic access
@@ -319,7 +334,7 @@ public abstract class CameraController {
         mPreview = new Preview.Builder().build();
         mImageCapture = new ImageCapture.Builder().build();
         mImageAnalysis = new ImageAnalysis.Builder().build();
-        mVideoCapture = new VideoCapture.Builder().build();
+        mVideoCapture = VideoCapture.withOutput(generateVideoCaptureRecorder(mVideoCaptureQuality));
 
         // Wait for camera to be initialized before binding use cases.
         mInitializationFuture = Futures.transform(
@@ -341,6 +356,18 @@ public abstract class CameraController {
         };
     }
 
+    private static Recorder generateVideoCaptureRecorder(Quality videoQuality) {
+        Recorder.Builder builder = new Recorder.Builder();
+        if (videoQuality != null) {
+            builder.setQualitySelector(QualitySelector.from(
+                    videoQuality,
+                    FallbackStrategy.lowerQualityOrHigherThan(videoQuality)
+            ));
+        }
+
+        return builder.build();
+    }
+
     /**
      * Gets the application context and preserves the attribution tag.
      *
@@ -424,7 +451,6 @@ public abstract class CameraController {
      * // Switch to video capture to shoot video.
      * controller.setEnabledUseCases(VIDEO_CAPTURE);
      * controller.startRecording(...);
-     * controller.stopRecording(...);
      *
      * // Switch back to image capture and image analysis before taking another picture.
      * controller.setEnabledUseCases(IMAGE_CAPTURE|IMAGE_ANALYSIS);
@@ -450,7 +476,7 @@ public abstract class CameraController {
         }
         int oldEnabledUseCases = mEnabledUseCases;
         mEnabledUseCases = enabledUseCases;
-        if (!isVideoCaptureEnabled()) {
+        if (!isVideoCaptureEnabled() && isRecording()) {
             stopRecording();
         }
         startCameraAndTrackStates(() -> mEnabledUseCases = oldEnabledUseCases);
@@ -647,7 +673,7 @@ public abstract class CameraController {
      * <p> By default, the saved image is mirrored to match the output of the preview if front
      * camera is used. To override this behavior, the app needs to explicitly set the flag to
      * {@code false} using {@link ImageCapture.Metadata#setReversedHorizontal} and
-     * {@link OutputFileOptions.Builder#setMetadata}.
+     * {@link ImageCapture.OutputFileOptions.Builder#setMetadata}.
      *
      * @param outputFileOptions  Options to store the newly captured image.
      * @param executor           The executor in which the callback methods will be run.
@@ -1117,98 +1143,284 @@ public abstract class CameraController {
     }
 
     /**
-     * Takes a video and calls the OnVideoSavedCallback when done.
+     * Takes a video to a given file.
+     *
+     * <p> Only a single recording can be active at a time, so if {@link #isRecording()} is true,
+     * this will throw an {@link IllegalStateException}.
      *
-     * @param outputFileOptions Options to store the newly captured video.
-     * @param executor          The executor in which the callback methods will be run.
-     * @param callback          Callback which will receive success or failure.
+     * <p> Upon successfully starting the recording, a {@link VideoRecordEvent.Start} event will
+     * be the first event sent to the provided event listener.
+     *
+     * <p> If errors occur while starting the recording, a {@link VideoRecordEvent.Finalize} event
+     * will be the first event sent to the provided listener, and information about the error can
+     * be found in that event's {@link VideoRecordEvent.Finalize#getError()} method.
+     *
+     * <p> Recording requires the {@link android.Manifest.permission#RECORD_AUDIO} permission;
+     * without it, starting a recording will fail with a {@link SecurityException}.
+     *
+     * @param outputOptions the options to store the newly captured video.
+     * @param executor the executor that the event listener will be run on.
+     * @param listener the event listener to handle video record events.
+     * @return a {@link Recording} that provides controls for new active recordings.
+     * @throws IllegalStateException if there is an unfinished active recording.
+     * @throws SecurityException if the {@link android.Manifest.permission#RECORD_AUDIO}
+     * permission is denied.
      */
-    @SuppressLint("MissingPermission")
+    @RequiresPermission(Manifest.permission.RECORD_AUDIO)
     @ExperimentalVideo
     @MainThread
-    public void startRecording(@NonNull OutputFileOptions outputFileOptions,
-            @NonNull Executor executor, final @NonNull OnVideoSavedCallback callback) {
+    @NonNull
+    public Recording startRecording(
+            @NonNull FileOutputOptions outputOptions,
+            @NonNull Executor executor,
+            @NonNull Consumer<VideoRecordEvent> listener) {
+        return startRecordingInternal(outputOptions, executor, listener);
+    }
+
+    /**
+     * Takes a video to a given file descriptor.
+     *
+     * <p> Currently, file descriptors as output destinations are not supported on pre-Android O
+     * (API 26) devices.
+     *
+     * <p> Only a single recording can be active at a time, so if {@link #isRecording()} is true,
+     * this will throw an {@link IllegalStateException}.
+     *
+     * <p> Upon successfully starting the recording, a {@link VideoRecordEvent.Start} event will
+     * be the first event sent to the provided event listener.
+     *
+     * <p> If errors occur while starting the recording, a {@link VideoRecordEvent.Finalize} event
+     * will be the first event sent to the provided listener, and information about the error can
+     * be found in that event's {@link VideoRecordEvent.Finalize#getError()} method.
+     *
+     * <p> Recording requires the {@link android.Manifest.permission#RECORD_AUDIO} permission;
+     * without it, starting a recording will fail with a {@link SecurityException}.
+     *
+     * @param outputOptions the options to store the newly captured video.
+     * @param executor the executor that the event listener will be run on.
+     * @param listener the event listener to handle video record events.
+     * @return a {@link Recording} that provides controls for new active recordings.
+     * @throws IllegalStateException if there is an unfinished active recording.
+     * @throws SecurityException if the {@link android.Manifest.permission#RECORD_AUDIO}
+     * permission is denied.
+     */
+    @RequiresPermission(Manifest.permission.RECORD_AUDIO)
+    @ExperimentalVideo
+    @RequiresApi(26)
+    @MainThread
+    @NonNull
+    public Recording startRecording(
+            @NonNull FileDescriptorOutputOptions outputOptions,
+            @NonNull Executor executor,
+            @NonNull Consumer<VideoRecordEvent> listener) {
+        return startRecordingInternal(outputOptions, executor, listener);
+    }
+
+    /**
+     * Takes a video to MediaStore.
+     *
+     * <p> Only a single recording can be active at a time, so if {@link #isRecording()} is true,
+     * this will throw an {@link IllegalStateException}.
+     *
+     * <p> Upon successfully starting the recording, a {@link VideoRecordEvent.Start} event will
+     * be the first event sent to the provided event listener.
+     *
+     * <p> If errors occur while starting the recording, a {@link VideoRecordEvent.Finalize} event
+     * will be the first event sent to the provided listener, and information about the error can
+     * be found in that event's {@link VideoRecordEvent.Finalize#getError()} method.
+     *
+     * <p> Recording requires the {@link android.Manifest.permission#RECORD_AUDIO} permission;
+     * without it, starting a recording will fail with a {@link SecurityException}.
+     *
+     * @param outputOptions the options to store the newly captured video.
+     * @param executor the executor that the event listener will be run on.
+     * @param listener the event listener to handle video record events.
+     * @return a {@link Recording} that provides controls for new active recordings.
+     * @throws IllegalStateException if there is an unfinished active recording.
+     * @throws SecurityException if the {@link android.Manifest.permission#RECORD_AUDIO}
+     * permission is denied.
+     */
+    @RequiresPermission(Manifest.permission.RECORD_AUDIO)
+    @ExperimentalVideo
+    @MainThread
+    @NonNull
+    public Recording startRecording(
+            @NonNull MediaStoreOutputOptions outputOptions,
+            @NonNull Executor executor,
+            @NonNull Consumer<VideoRecordEvent> listener) {
+        return startRecordingInternal(outputOptions, executor, listener);
+    }
+
+    @RequiresPermission(Manifest.permission.RECORD_AUDIO)
+    @ExperimentalVideo
+    @MainThread
+    private Recording startRecordingInternal(
+            @NonNull OutputOptions outputOptions,
+            @NonNull Executor executor,
+            @NonNull Consumer<VideoRecordEvent> listener) {
         checkMainThread();
         Preconditions.checkState(isCameraInitialized(), CAMERA_NOT_INITIALIZED);
         Preconditions.checkState(isVideoCaptureEnabled(), VIDEO_CAPTURE_DISABLED);
+        Preconditions.checkState(!isRecording(), VIDEO_RECORDING_UNFINISHED);
 
-        mVideoCapture.startRecording(outputFileOptions.toVideoCaptureOutputFileOptions(), executor,
-                new VideoCapture.OnVideoSavedCallback() {
-                    @Override
-                    public void onVideoSaved(
-                            @NonNull VideoCapture.OutputFileResults outputFileResults) {
-                        mVideoIsRecording.set(false);
-                        callback.onVideoSaved(
-                                OutputFileResults.create(outputFileResults.getSavedUri()));
-                    }
+        Consumer<VideoRecordEvent> wrappedListener =
+                wrapListenerToDeactivateRecordingOnFinalized(listener);
+        PendingRecording pendingRecording = prepareRecording(outputOptions).withAudioEnabled();
+        Recording recording = pendingRecording.start(executor, wrappedListener);
+        setActiveRecording(recording, wrappedListener);
 
-                    @Override
-                    public void onError(int videoCaptureError, @NonNull String message,
-                            @Nullable Throwable cause) {
-                        mVideoIsRecording.set(false);
-                        callback.onError(videoCaptureError, message, cause);
+        return recording;
+    }
+
+    /**
+     * Generates a {@link PendingRecording} instance for starting a recording.
+     *
+     * <p> This method handles {@code prepareRecording()} methods for different output formats,
+     * and makes {@link #startRecordingInternal(OutputOptions, Executor, Consumer)} only handle
+     * the general flow.
+     *
+     * <p> This method uses the parent class {@link OutputOptions} as the parameter. On the other
+     * hand, the public {@code startRecording()} is overloaded with subclasses. The reason is to
+     * enforce compile-time check for API levels.
+     */
+    @ExperimentalVideo
+    @MainThread
+    private PendingRecording prepareRecording(@NonNull OutputOptions options) {
+        Recorder recorder = mVideoCapture.getOutput();
+        if (options instanceof FileOutputOptions) {
+            return recorder.prepareRecording(mAppContext, (FileOutputOptions) options);
+        } else if (options instanceof FileDescriptorOutputOptions) {
+            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
+                throw new UnsupportedOperationException(
+                        "File descriptors are not supported on pre-Android O (API 26) devices."
+                );
+            }
+            return recorder.prepareRecording(mAppContext, (FileDescriptorOutputOptions) options);
+        } else if (options instanceof MediaStoreOutputOptions) {
+            return recorder.prepareRecording(mAppContext, (MediaStoreOutputOptions) options);
+        } else {
+            throw new IllegalArgumentException("Unsupported OutputOptions type.");
+        }
+    }
+
+    @ExperimentalVideo
+    private Consumer<VideoRecordEvent> wrapListenerToDeactivateRecordingOnFinalized(
+            @NonNull final Consumer<VideoRecordEvent> listener) {
+        final Executor mainExecutor = getMainExecutor(mAppContext);
+
+        return new Consumer<VideoRecordEvent>() {
+            @Override
+            public void accept(VideoRecordEvent videoRecordEvent) {
+                if (videoRecordEvent instanceof VideoRecordEvent.Finalize) {
+                    if (!Threads.isMainThread()) {
+                        // Post on main thread to ensure thread safety.
+                        mainExecutor.execute(() -> deactivateRecordingByListener(this));
+                    } else {
+                        deactivateRecordingByListener(this);
                     }
-                });
-        mVideoIsRecording.set(true);
+                }
+                listener.accept(videoRecordEvent);
+            }
+        };
+    }
+
+    @ExperimentalVideo
+    @MainThread
+    void deactivateRecordingByListener(@NonNull Consumer<VideoRecordEvent> listener) {
+        Recording recording = mRecordingMap.remove(listener);
+        if (recording != null) {
+            deactivateRecording(recording);
+        }
+    }
+
+    /**
+     * Clears the active video recording reference if the recording to be deactivated matches.
+     */
+    @ExperimentalVideo
+    @MainThread
+    private void deactivateRecording(@NonNull Recording recording) {
+        if (mActiveRecording == recording) {
+            mActiveRecording = null;
+        }
+    }
+
+    @ExperimentalVideo
+    @MainThread
+    private void setActiveRecording(
+            @NonNull Recording recording,
+            @NonNull Consumer<VideoRecordEvent> listener) {
+        mRecordingMap.put(listener, recording);
+        mActiveRecording = recording;
     }
 
     /**
-     * Stops a in progress video recording.
+     * Stops an in-progress video recording.
+     *
+     * <p> Once the current recording has been stopped, the next recording can be started.
+     *
+     * <p> If the recording completes successfully, a {@link VideoRecordEvent.Finalize} event with
+     * {@link VideoRecordEvent.Finalize#ERROR_NONE} will be sent to the provided listener.
      */
     @ExperimentalVideo
     @MainThread
-    public void stopRecording() {
+    private void stopRecording() {
         checkMainThread();
-        if (mVideoIsRecording.get()) {
-            mVideoCapture.stopRecording();
+
+        if (mActiveRecording != null) {
+            mActiveRecording.stop();
+            deactivateRecording(mActiveRecording);
         }
     }
 
     /**
-     * Returns whether there is a in progress video recording.
+     * Returns whether there is an in-progress video recording.
      */
     @ExperimentalVideo
     @MainThread
     public boolean isRecording() {
         checkMainThread();
-        return mVideoIsRecording.get();
+        return mActiveRecording != null && !mActiveRecording.isClosed();
     }
 
     /**
-     * Sets the intended video size for {@code VideoCapture}.
+     * Sets the intended video quality for {@code VideoCapture}.
      *
-     * <p> The value is used as a hint when determining the resolution and aspect ratio of
-     * the video. The actual output may differ from the requested value due to device constraints.
+     * <p> The value is used as a hint when determining the resolution of the video.
+     * The actual output may differ from the requested value due to device constraints.
+     * The {@link FallbackStrategy#lowerQualityOrHigherThan(Quality)} fallback strategy
+     * will be applied when the quality is not supported.
      *
-     * <p> When set to null, the output will be based on the default config of {@code VideoCapture}.
+     * <p> When set to null, the output will be based on the default config of {@link
+     * Recorder#DEFAULT_QUALITY_SELECTOR}.
      *
-     * <p> Changing the value will reconfigure the camera which will cause video capture to stop.
-     * To avoid this, set the value before controller is bound to lifecycle.
+     * <p> Changing the value will reconfigure the camera which will cause video
+     * capture to stop. To avoid this, set the value before controller is bound to
+     * lifecycle.
      *
-     * @param targetSize the intended video size for {@code VideoCapture}.
+     * @param targetQuality the intended video quality for {@code VideoCapture}.
      */
     @ExperimentalVideo
     @MainThread
-    public void setVideoCaptureTargetSize(@Nullable OutputSize targetSize) {
+    public void setVideoCaptureTargetQuality(@Nullable Quality targetQuality) {
         checkMainThread();
-        if (isOutputSizeEqual(mVideoCaptureOutputSize, targetSize)) {
+        if (targetQuality == mVideoCaptureQuality) {
             return;
         }
-        mVideoCaptureOutputSize = targetSize;
+        mVideoCaptureQuality = targetQuality;
         unbindVideoAndRecreate();
         startCameraAndTrackStates();
     }
 
     /**
-     * Returns the intended output size for {@code VideoCapture} set by
-     * {@link #setVideoCaptureTargetSize(OutputSize)}, or null if not set.
+     * Returns the intended quality for {@code VideoCapture} set by
+     * {@link #setVideoCaptureTargetQuality(Quality)}, or null if not set.
      */
     @ExperimentalVideo
     @MainThread
     @Nullable
-    public OutputSize getVideoCaptureTargetSize() {
+    public Quality getVideoCaptureTargetQuality() {
         checkMainThread();
-        return mVideoCaptureOutputSize;
+        return mVideoCaptureQuality;
     }
 
     /**
@@ -1218,9 +1430,7 @@ public abstract class CameraController {
         if (isCameraInitialized()) {
             mCameraProvider.unbind(mVideoCapture);
         }
-        VideoCapture.Builder builder = new VideoCapture.Builder();
-        setTargetOutputSize(builder, mVideoCaptureOutputSize);
-        mVideoCapture = builder.build();
+        mVideoCapture = VideoCapture.withOutput(generateVideoCaptureRecorder(mVideoCaptureQuality));
     }
 
     // -----------------
@@ -1801,7 +2011,6 @@ public abstract class CameraController {
      * @see #setImageAnalysisTargetSize(OutputSize)
      * @see #setPreviewTargetSize(OutputSize)
      * @see #setImageCaptureTargetSize(OutputSize)
-     * @see #setVideoCaptureTargetSize(OutputSize)
      */
     @RequiresApi(21) // TODO(b/200306659): Remove and replace with annotation on package-info.java
     public static final class OutputSize {
diff --git a/camera/camera-view/src/test/java/androidx/camera/view/CameraControllerTest.kt b/camera/camera-view/src/test/java/androidx/camera/view/CameraControllerTest.kt
index d69c153dd2f..b85fa8a440e 100644
--- a/camera/camera-view/src/test/java/androidx/camera/view/CameraControllerTest.kt
+++ b/camera/camera-view/src/test/java/androidx/camera/view/CameraControllerTest.kt
@@ -36,6 +36,7 @@ import androidx.camera.lifecycle.ProcessCameraProvider
 import androidx.camera.testing.fakes.FakeAppConfig
 import androidx.camera.view.CameraController.COORDINATE_SYSTEM_VIEW_REFERENCED
 import androidx.camera.view.transform.OutputTransform
+import androidx.camera.video.Quality
 import androidx.test.annotation.UiThreadTest
 import androidx.test.core.app.ApplicationProvider
 import com.google.common.truth.Truth.assertThat
@@ -64,6 +65,7 @@ public class CameraControllerTest {
         CameraController.OutputSize(AspectRatio.RATIO_16_9)
     private val targetSizeWithResolution =
         CameraController.OutputSize(Size(1080, 1960))
+    private val targetVideoQuality = Quality.HIGHEST
 
     @Before
     public fun setUp() {
@@ -287,22 +289,9 @@ public class CameraControllerTest {
 
     @UiThreadTest
     @Test
-    public fun setVideoCaptureResolution() {
-        controller.videoCaptureTargetSize = targetSizeWithResolution
-        assertThat(controller.videoCaptureTargetSize).isEqualTo(targetSizeWithResolution)
-
-        val config = controller.mVideoCapture.currentConfig as ImageOutputConfig
-        assertThat(config.targetResolution).isEqualTo(targetSizeWithResolution.resolution)
-    }
-
-    @UiThreadTest
-    @Test
-    public fun setVideoCaptureAspectRatio() {
-        controller.videoCaptureTargetSize = targetSizeWithAspectRatio
-        assertThat(controller.videoCaptureTargetSize).isEqualTo(targetSizeWithAspectRatio)
-
-        val config = controller.mVideoCapture.currentConfig as ImageOutputConfig
-        assertThat(config.targetAspectRatio).isEqualTo(targetSizeWithAspectRatio.aspectRatio)
+    fun setVideoCaptureQuality() {
+        controller.videoCaptureTargetQuality = targetVideoQuality
+        assertThat(controller.videoCaptureTargetQuality).isEqualTo(targetVideoQuality)
     }
 
     @UiThreadTest
diff --git a/camera/integration-tests/viewtestapp/build.gradle b/camera/integration-tests/viewtestapp/build.gradle
index 75139ec2ac6..794f5d80d0a 100644
--- a/camera/integration-tests/viewtestapp/build.gradle
+++ b/camera/integration-tests/viewtestapp/build.gradle
@@ -63,6 +63,7 @@ dependencies {
     implementation(project(":camera:camera-mlkit-vision"))
     implementation("androidx.lifecycle:lifecycle-runtime:2.3.1")
     implementation(project(":camera:camera-view"))
+    implementation(project(":camera:camera-video"))
     implementation(libs.guavaAndroid)
     implementation('com.google.mlkit:barcode-scanning:17.0.2')
     implementation("androidx.exifinterface:exifinterface:1.3.2")
diff --git a/camera/integration-tests/viewtestapp/src/androidTest/java/androidx/camera/integration/view/CameraControllerFragmentTest.kt b/camera/integration-tests/viewtestapp/src/androidTest/java/androidx/camera/integration/view/CameraControllerFragmentTest.kt
index 20a3a1b62c2..1e5a16ad330 100644
--- a/camera/integration-tests/viewtestapp/src/androidTest/java/androidx/camera/integration/view/CameraControllerFragmentTest.kt
+++ b/camera/integration-tests/viewtestapp/src/androidTest/java/androidx/camera/integration/view/CameraControllerFragmentTest.kt
@@ -21,6 +21,7 @@ import android.graphics.Bitmap
 import android.graphics.BitmapFactory
 import android.graphics.Matrix
 import android.graphics.PointF
+import android.media.MediaMetadataRetriever
 import android.net.Uri
 import android.os.Build
 import android.view.Surface
@@ -39,6 +40,7 @@ import androidx.camera.lifecycle.ProcessCameraProvider
 import androidx.camera.testing.CameraPipeConfigTestRule
 import androidx.camera.testing.CameraUtil
 import androidx.camera.testing.CoreAppTestUtil
+import androidx.camera.video.VideoRecordEvent
 import androidx.camera.view.CameraController.TAP_TO_FOCUS_FAILED
 import androidx.camera.view.CameraController.TAP_TO_FOCUS_FOCUSED
 import androidx.camera.view.CameraController.TAP_TO_FOCUS_NOT_FOCUSED
@@ -442,6 +444,92 @@ class CameraControllerFragmentTest(
         fragment.assertCanTakePicture()
     }
 
+    @Test
+    fun fragmentLaunched_cannotRecordVideo() {
+        skipVideoRecordingTestOnCuttlefishApi29()
+
+        // Arrange.
+        fragment.assertPreviewIsStreaming()
+
+        // Assert.
+        val exception = Assert.assertThrows(IllegalStateException::class.java) {
+            fragment.assertCanRecordVideo()
+        }
+        assertThat(exception).hasMessageThat().isEqualTo("VideoCapture disabled.")
+    }
+
+    @Test
+    fun recordEnabled_canRecordVideo() {
+        skipVideoRecordingTestOnCuttlefishApi29()
+
+        // Arrange.
+        fragment.assertPreviewIsStreaming()
+
+        // Act.
+        invertAllUseCaseEnableStatusExceptPreview()
+        fragment.assertPreviewIsStreaming()
+
+        // Assert.
+        fragment.assertCanRecordVideo()
+    }
+
+    @Ignore
+    @Test
+    fun cameraToggled_canRecordVideo() {
+        // TODO: Enable after we resolve b/212332039.
+
+        skipVideoRecordingTestOnCuttlefishApi29()
+
+        // Arrange.
+        fragment.assertPreviewIsStreaming()
+
+        // Act.
+        invertAllUseCaseEnableStatusExceptPreview()
+        fragment.assertPreviewIsStreaming()
+        onView(withId(R.id.camera_toggle)).perform(click())
+        fragment.assertPreviewIsStreaming()
+
+        // Assert.
+        fragment.assertCanRecordVideo()
+    }
+
+    @Ignore
+    @Test
+    fun recordDisabledAndEnabledMultipleTimes_canRecordVideo() {
+        // TODO: Enable after we resolve b/211832281.
+
+        skipVideoRecordingTestOnCuttlefishApi29()
+
+        // Arrange.
+        val times = 10
+        fragment.assertPreviewIsStreaming()
+
+        // Act.
+        invertAllUseCaseEnableStatusExceptPreview()
+        repeat(times) {
+            onView(withId(R.id.video_enabled)).perform(click())
+            onView(withId(R.id.video_enabled)).perform(click())
+        }
+        fragment.assertPreviewIsStreaming()
+
+        // Assert.
+        fragment.assertCanRecordVideo()
+    }
+
+    private fun invertAllUseCaseEnableStatusExceptPreview() {
+        onView(withId(R.id.capture_enabled)).perform(click())
+        onView(withId(R.id.analysis_enabled)).perform(click())
+        onView(withId(R.id.video_enabled)).perform(click())
+    }
+
+    private fun skipVideoRecordingTestOnCuttlefishApi29() {
+        // Skip test for b/168175357
+        Assume.assumeFalse(
+            "Cuttlefish has MediaCodec dequeInput/Output buffer fails issue. Unable to test.",
+            Build.MODEL.contains("Cuttlefish") && Build.VERSION.SDK_INT == 29
+        )
+    }
+
     /**
      * Calculates the 1st order moment (center of mass) of the R, G and B of the bitmap.
      */
@@ -564,6 +652,73 @@ class CameraControllerFragmentTest(
         )
     }
 
+    /**
+     * Records a video and assert the URI exists.
+     *
+     * <p> Also cleans up the saved video afterwards.
+     */
+    private fun CameraControllerFragment.assertCanRecordVideo() {
+        // Arrange.
+        val videoSavedSemaphore = Semaphore(0)
+        val videoRecordingSemaphore = Semaphore(0)
+        var finalize: VideoRecordEvent.Finalize? = null
+
+        // Act.
+        instrumentation.runOnMainSync {
+            this.startRecording {
+                when (it) {
+                    is VideoRecordEvent.Finalize -> {
+                        finalize = it
+                        videoSavedSemaphore.release()
+                    }
+                    is VideoRecordEvent.Status -> {
+                        videoRecordingSemaphore.release()
+                    }
+                    is VideoRecordEvent.Start,
+                    is VideoRecordEvent.Pause,
+                    is VideoRecordEvent.Resume -> {
+                        // no op for this test, skip these event now.
+                    }
+                    else -> {
+                        throw IllegalStateException()
+                    }
+                }
+            }
+        }
+
+        // Wait for status event to proceed recording for a while.
+        assertThat(
+            videoRecordingSemaphore.tryAcquire(RECORDING_COUNT, TIMEOUT_SECONDS, TimeUnit.SECONDS)
+        ).isTrue()
+
+        instrumentation.runOnMainSync {
+            this.stopRecording()
+        }
+
+        // Wait for finalize event to saved file.
+        assertThat(videoSavedSemaphore.tryAcquire(TIMEOUT_SECONDS, TimeUnit.SECONDS)).isTrue()
+        assertThat(finalize).isNotEqualTo(null)
+        assertThat(finalize!!.hasError()).isFalse()
+
+        // Verify.
+        val uri = finalize!!.outputResults.outputUri
+        assertThat(uri).isNotEqualTo(Uri.EMPTY)
+        checkFileVideo(uri)
+
+        // Cleanup.
+        val contentResolver: ContentResolver = this.activity!!.contentResolver
+        contentResolver.delete(uri, null, null)
+    }
+
+    private fun checkFileVideo(uri: Uri) {
+        val mediaRetriever = MediaMetadataRetriever()
+        mediaRetriever.apply {
+            setDataSource(ApplicationProvider.getApplicationContext(), uri)
+            val hasVideo = extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_VIDEO)
+            assertThat(hasVideo).isEqualTo("yes")
+        }
+    }
+
     private fun createFragmentScenario(): FragmentScenario<CameraControllerFragment> {
         return FragmentScenario.launchInContainer(
             CameraControllerFragment::class.java, null, R.style.AppTheme,
@@ -638,6 +793,7 @@ class CameraControllerFragmentTest(
         val testCameraRule = CameraUtil.PreTestCamera()
 
         const val TIMEOUT_SECONDS = 10L
+        const val RECORDING_COUNT = 5
 
         @JvmStatic
         @Parameterized.Parameters(name = "{0}")
diff --git a/camera/integration-tests/viewtestapp/src/main/java/androidx/camera/integration/view/CameraControllerFragment.java b/camera/integration-tests/viewtestapp/src/main/java/androidx/camera/integration/view/CameraControllerFragment.java
index 14833f19009..e3f7c96973b 100644
--- a/camera/integration-tests/viewtestapp/src/main/java/androidx/camera/integration/view/CameraControllerFragment.java
+++ b/camera/integration-tests/viewtestapp/src/main/java/androidx/camera/integration/view/CameraControllerFragment.java
@@ -17,10 +17,13 @@
 package androidx.camera.integration.view;
 
 import static androidx.camera.core.impl.utils.executor.CameraXExecutors.mainThreadExecutor;
+import static androidx.camera.video.VideoRecordEvent.Finalize.ERROR_NONE;
 
+import android.Manifest;
 import android.annotation.SuppressLint;
 import android.content.ContentResolver;
 import android.content.ContentValues;
+import android.net.Uri;
 import android.os.Bundle;
 import android.os.Environment;
 import android.provider.MediaStore;
@@ -36,9 +39,11 @@ import android.widget.TextView;
 import android.widget.Toast;
 import android.widget.ToggleButton;
 
+import androidx.annotation.MainThread;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.OptIn;
+import androidx.annotation.RequiresPermission;
 import androidx.annotation.RestrictTo;
 import androidx.annotation.VisibleForTesting;
 import androidx.camera.core.CameraSelector;
@@ -51,14 +56,15 @@ import androidx.camera.core.SurfaceEffect;
 import androidx.camera.core.ZoomState;
 import androidx.camera.core.impl.utils.futures.FutureCallback;
 import androidx.camera.core.impl.utils.futures.Futures;
+import androidx.camera.video.MediaStoreOutputOptions;
+import androidx.camera.video.Recording;
+import androidx.camera.video.VideoRecordEvent;
 import androidx.camera.view.CameraController;
 import androidx.camera.view.LifecycleCameraController;
 import androidx.camera.view.PreviewView;
 import androidx.camera.view.RotationProvider;
 import androidx.camera.view.video.ExperimentalVideo;
-import androidx.camera.view.video.OnVideoSavedCallback;
-import androidx.camera.view.video.OutputFileOptions;
-import androidx.camera.view.video.OutputFileResults;
+import androidx.core.util.Consumer;
 import androidx.fragment.app.Fragment;
 import androidx.lifecycle.LiveData;
 
@@ -105,6 +111,21 @@ public class CameraControllerFragment extends Fragment {
     private RotationProvider mRotationProvider;
     private int mRotation;
     private final RotationProvider.Listener mRotationListener = rotation -> mRotation = rotation;
+    @Nullable private Recording mActiveRecording = null;
+    private final Consumer<VideoRecordEvent> mVideoRecordEventListener = videoRecordEvent -> {
+        if (videoRecordEvent instanceof VideoRecordEvent.Finalize) {
+            VideoRecordEvent.Finalize finalize = (VideoRecordEvent.Finalize) videoRecordEvent;
+            Uri uri = finalize.getOutputResults().getOutputUri();
+
+            if (finalize.getError() == ERROR_NONE) {
+                toast("Video saved to: " + uri);
+            } else {
+                String msg = "Saved uri " + uri;
+                msg += " with code (" + finalize.getError() + ")";
+                toast("Failed to save video: " + msg);
+            }
+        }
+    };
 
     // Wrapped analyzer for tests to receive callbacks.
     @Nullable
@@ -131,6 +152,21 @@ public class CameraControllerFragment extends Fragment {
         image.close();
     };
 
+    @NonNull
+    private MediaStoreOutputOptions getNewVideoOutputMediaStoreOptions() {
+        String videoFileName = "video_" + System.currentTimeMillis();
+        ContentResolver resolver = requireContext().getContentResolver();
+        ContentValues contentValues = new ContentValues();
+        contentValues.put(MediaStore.MediaColumns.MIME_TYPE, "video/mp4");
+        contentValues.put(MediaStore.Video.Media.TITLE, videoFileName);
+        contentValues.put(MediaStore.Video.Media.DISPLAY_NAME, videoFileName);
+        return new MediaStoreOutputOptions
+                .Builder(resolver, MediaStore.Video.Media.EXTERNAL_CONTENT_URI)
+                .setContentValues(contentValues)
+                .build();
+    }
+
+    @RequiresPermission(Manifest.permission.RECORD_AUDIO)
     @NonNull
     @Override
     @OptIn(markerClass = ExperimentalVideo.class)
@@ -260,30 +296,7 @@ public class CameraControllerFragment extends Fragment {
 
         view.findViewById(R.id.video_record).setOnClickListener(v -> {
             try {
-                String videoFileName = "video_" + System.currentTimeMillis();
-                ContentResolver resolver = requireContext().getContentResolver();
-                ContentValues contentValues = new ContentValues();
-                contentValues.put(MediaStore.MediaColumns.MIME_TYPE, "video/mp4");
-                contentValues.put(MediaStore.Video.Media.TITLE, videoFileName);
-                contentValues.put(MediaStore.Video.Media.DISPLAY_NAME, videoFileName);
-                OutputFileOptions outputFileOptions = OutputFileOptions.builder(resolver,
-                        MediaStore.Video.Media.EXTERNAL_CONTENT_URI, contentValues).build();
-                mCameraController.startRecording(outputFileOptions, mExecutorService,
-                        new OnVideoSavedCallback() {
-                            @Override
-                            public void onVideoSaved(
-                                    @NonNull OutputFileResults outputFileResults) {
-                                toast("Video saved to: "
-                                        + outputFileResults.getSavedUri());
-                            }
-
-                            @Override
-                            public void onError(int videoCaptureError,
-                                    @NonNull String message,
-                                    @Nullable Throwable cause) {
-                                toast("Failed to save video: " + message);
-                            }
-                        });
+                startRecording(mVideoRecordEventListener);
             } catch (RuntimeException exception) {
                 toast("Failed to record video: " + exception.getMessage());
             }
@@ -291,7 +304,7 @@ public class CameraControllerFragment extends Fragment {
         });
         view.findViewById(R.id.video_stop_recording).setOnClickListener(
                 v -> {
-                    mCameraController.stopRecording();
+                    stopRecording();
                     updateUiText();
                 });
 
@@ -558,4 +571,23 @@ public class CameraControllerFragment extends Fragment {
         mCameraController.takePicture(outputFileOptions, mExecutorService, callback);
     }
 
+    @RequiresPermission(Manifest.permission.RECORD_AUDIO)
+    @VisibleForTesting
+    @MainThread
+    @OptIn(markerClass = ExperimentalVideo.class)
+    void startRecording(Consumer<VideoRecordEvent> listener) {
+        MediaStoreOutputOptions outputOptions = getNewVideoOutputMediaStoreOptions();
+        mActiveRecording = mCameraController.startRecording(outputOptions, mExecutorService,
+                listener);
+    }
+
+    @VisibleForTesting
+    @MainThread
+    @OptIn(markerClass = ExperimentalVideo.class)
+    void stopRecording() {
+        if (mActiveRecording != null) {
+            mActiveRecording.stop();
+        }
+    }
+
 }
-- 
2.37.2

